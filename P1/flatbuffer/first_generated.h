// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FIRST_SAMPLE_H_
#define FLATBUFFERS_GENERATED_FIRST_SAMPLE_H_

#include "flatbuffers/flatbuffers.h"

namespace Sample {

struct Born;
struct BornBuilder;

struct Car;
struct CarBuilder;

struct Home;
struct HomeBuilder;

struct PersonFirst;
struct PersonFirstBuilder;

struct Born FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BornBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATE = 4,
    VT_CITY = 6
  };
  const flatbuffers::String *date() const {
    return GetPointer<const flatbuffers::String *>(VT_DATE);
  }
  const flatbuffers::String *city() const {
    return GetPointer<const flatbuffers::String *>(VT_CITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATE) &&
           verifier.VerifyString(date()) &&
           VerifyOffset(verifier, VT_CITY) &&
           verifier.VerifyString(city()) &&
           verifier.EndTable();
  }
};

struct BornBuilder {
  typedef Born Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_date(flatbuffers::Offset<flatbuffers::String> date) {
    fbb_.AddOffset(Born::VT_DATE, date);
  }
  void add_city(flatbuffers::Offset<flatbuffers::String> city) {
    fbb_.AddOffset(Born::VT_CITY, city);
  }
  explicit BornBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Born> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Born>(end);
    return o;
  }
};

inline flatbuffers::Offset<Born> CreateBorn(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> date = 0,
    flatbuffers::Offset<flatbuffers::String> city = 0) {
  BornBuilder builder_(_fbb);
  builder_.add_city(city);
  builder_.add_date(date);
  return builder_.Finish();
}

inline flatbuffers::Offset<Born> CreateBornDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *date = nullptr,
    const char *city = nullptr) {
  auto date__ = date ? _fbb.CreateString(date) : 0;
  auto city__ = city ? _fbb.CreateString(city) : 0;
  return Sample::CreateBorn(
      _fbb,
      date__,
      city__);
}

struct Car FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CarBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODEL_NAME = 4,
    VT_FACTORY_YEAR = 6,
    VT_LICENSE_PLATE = 8
  };
  const flatbuffers::String *model_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MODEL_NAME);
  }
  int32_t factory_year() const {
    return GetField<int32_t>(VT_FACTORY_YEAR, 0);
  }
  const flatbuffers::String *license_plate() const {
    return GetPointer<const flatbuffers::String *>(VT_LICENSE_PLATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODEL_NAME) &&
           verifier.VerifyString(model_name()) &&
           VerifyField<int32_t>(verifier, VT_FACTORY_YEAR) &&
           VerifyOffset(verifier, VT_LICENSE_PLATE) &&
           verifier.VerifyString(license_plate()) &&
           verifier.EndTable();
  }
};

struct CarBuilder {
  typedef Car Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_model_name(flatbuffers::Offset<flatbuffers::String> model_name) {
    fbb_.AddOffset(Car::VT_MODEL_NAME, model_name);
  }
  void add_factory_year(int32_t factory_year) {
    fbb_.AddElement<int32_t>(Car::VT_FACTORY_YEAR, factory_year, 0);
  }
  void add_license_plate(flatbuffers::Offset<flatbuffers::String> license_plate) {
    fbb_.AddOffset(Car::VT_LICENSE_PLATE, license_plate);
  }
  explicit CarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Car> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Car>(end);
    return o;
  }
};

inline flatbuffers::Offset<Car> CreateCar(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> model_name = 0,
    int32_t factory_year = 0,
    flatbuffers::Offset<flatbuffers::String> license_plate = 0) {
  CarBuilder builder_(_fbb);
  builder_.add_license_plate(license_plate);
  builder_.add_factory_year(factory_year);
  builder_.add_model_name(model_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Car> CreateCarDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *model_name = nullptr,
    int32_t factory_year = 0,
    const char *license_plate = nullptr) {
  auto model_name__ = model_name ? _fbb.CreateString(model_name) : 0;
  auto license_plate__ = license_plate ? _fbb.CreateString(license_plate) : 0;
  return Sample::CreateCar(
      _fbb,
      model_name__,
      factory_year,
      license_plate__);
}

struct Home FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HomeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_OWNERSHIP = 6
  };
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  const flatbuffers::String *ownership() const {
    return GetPointer<const flatbuffers::String *>(VT_OWNERSHIP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.VerifyString(address()) &&
           VerifyOffset(verifier, VT_OWNERSHIP) &&
           verifier.VerifyString(ownership()) &&
           verifier.EndTable();
  }
};

struct HomeBuilder {
  typedef Home Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(Home::VT_ADDRESS, address);
  }
  void add_ownership(flatbuffers::Offset<flatbuffers::String> ownership) {
    fbb_.AddOffset(Home::VT_OWNERSHIP, ownership);
  }
  explicit HomeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Home> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Home>(end);
    return o;
  }
};

inline flatbuffers::Offset<Home> CreateHome(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    flatbuffers::Offset<flatbuffers::String> ownership = 0) {
  HomeBuilder builder_(_fbb);
  builder_.add_ownership(ownership);
  builder_.add_address(address);
  return builder_.Finish();
}

inline flatbuffers::Offset<Home> CreateHomeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *address = nullptr,
    const char *ownership = nullptr) {
  auto address__ = address ? _fbb.CreateString(address) : 0;
  auto ownership__ = ownership ? _fbb.CreateString(ownership) : 0;
  return Sample::CreateHome(
      _fbb,
      address__,
      ownership__);
}

struct PersonFirst FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PersonFirstBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_BORN = 6,
    VT_CAR = 8,
    VT_HOME = 10,
    VT_JOB = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const Sample::Born *born() const {
    return GetPointer<const Sample::Born *>(VT_BORN);
  }
  const Sample::Car *car() const {
    return GetPointer<const Sample::Car *>(VT_CAR);
  }
  const Sample::Home *home() const {
    return GetPointer<const Sample::Home *>(VT_HOME);
  }
  const flatbuffers::String *job() const {
    return GetPointer<const flatbuffers::String *>(VT_JOB);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_BORN) &&
           verifier.VerifyTable(born()) &&
           VerifyOffset(verifier, VT_CAR) &&
           verifier.VerifyTable(car()) &&
           VerifyOffset(verifier, VT_HOME) &&
           verifier.VerifyTable(home()) &&
           VerifyOffset(verifier, VT_JOB) &&
           verifier.VerifyString(job()) &&
           verifier.EndTable();
  }
};

struct PersonFirstBuilder {
  typedef PersonFirst Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PersonFirst::VT_NAME, name);
  }
  void add_born(flatbuffers::Offset<Sample::Born> born) {
    fbb_.AddOffset(PersonFirst::VT_BORN, born);
  }
  void add_car(flatbuffers::Offset<Sample::Car> car) {
    fbb_.AddOffset(PersonFirst::VT_CAR, car);
  }
  void add_home(flatbuffers::Offset<Sample::Home> home) {
    fbb_.AddOffset(PersonFirst::VT_HOME, home);
  }
  void add_job(flatbuffers::Offset<flatbuffers::String> job) {
    fbb_.AddOffset(PersonFirst::VT_JOB, job);
  }
  explicit PersonFirstBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PersonFirst> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PersonFirst>(end);
    return o;
  }
};

inline flatbuffers::Offset<PersonFirst> CreatePersonFirst(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<Sample::Born> born = 0,
    flatbuffers::Offset<Sample::Car> car = 0,
    flatbuffers::Offset<Sample::Home> home = 0,
    flatbuffers::Offset<flatbuffers::String> job = 0) {
  PersonFirstBuilder builder_(_fbb);
  builder_.add_job(job);
  builder_.add_home(home);
  builder_.add_car(car);
  builder_.add_born(born);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<PersonFirst> CreatePersonFirstDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<Sample::Born> born = 0,
    flatbuffers::Offset<Sample::Car> car = 0,
    flatbuffers::Offset<Sample::Home> home = 0,
    const char *job = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto job__ = job ? _fbb.CreateString(job) : 0;
  return Sample::CreatePersonFirst(
      _fbb,
      name__,
      born,
      car,
      home,
      job__);
}

inline const Sample::PersonFirst *GetPersonFirst(const void *buf) {
  return flatbuffers::GetRoot<Sample::PersonFirst>(buf);
}

inline const Sample::PersonFirst *GetSizePrefixedPersonFirst(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Sample::PersonFirst>(buf);
}

inline bool VerifyPersonFirstBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Sample::PersonFirst>(nullptr);
}

inline bool VerifySizePrefixedPersonFirstBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Sample::PersonFirst>(nullptr);
}

inline void FinishPersonFirstBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Sample::PersonFirst> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPersonFirstBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Sample::PersonFirst> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Sample

#endif  // FLATBUFFERS_GENERATED_FIRST_SAMPLE_H_
